package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/open-edge-platform/edge-manageability-framework/installer/internal"
	"github.com/open-edge-platform/edge-manageability-framework/installer/targets/demo"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
)

// TODO: make a flag for this
const DefaultTimeout = 60 * time.Minute

func main() {
	// Initialize the command line interface
	rootCmd := &cobra.Command{
		Use:   "orch-installer",
		Short: "Orchestrator Installer",
		Long:  `Orchestrator Installer for the Open Edge Platform`,
		Run:   func(cmd *cobra.Command, args []string) {},
	}

	// These flages are common to all commands
	var configFile, runtimeStateFile, logLevel, logDir string
	rootCmd.PersistentFlags().StringVarP(&configFile, "config", "c", "config.yaml", "Path to the configuration file")
	rootCmd.PersistentFlags().StringVarP(&runtimeStateFile, "runtime-state", "r", "runtime-state.yaml", "Path to the runtime state file")
	rootCmd.PersistentFlags().StringVarP(&logLevel, "log-level", "l", "info", "Log level (debug, info, warn, error)")
	rootCmd.PersistentFlags().StringVarP(&logDir, "log-dir", "o", ".logs", "Path to the log dir")

	commands := []struct {
		use   string
		short string
		long  string
	}{
		{"install", "Install the orchestrator", "Install the orchestrator"},
		{"uninstall", "Uninstall the orchestrator", "Uninstall the orchestrator"},
		{"upgrade", "Upgrade the orchestrator", "Upgrade the orchestrator"},
	}

	for _, cmd := range commands {
		c := &cobra.Command{
			Use:   cmd.use,
			Short: cmd.short,
			Long:  cmd.long,
			Run: func(cmd *cobra.Command, args []string) {
				err := internal.InitLogger(logLevel, logDir)
				if err != nil {
					zap.S().Fatalf("error initializing logger: %s", err)
				}
				execute(cmd.Name(), configFile, runtimeStateFile, logDir)
			},
		}
		rootCmd.AddCommand(c)
	}
	rootCmd.Execute()
}

func execute(action string, orchConfigFile string, runtimeStateFile string, logDir string) {
	logger := zap.S()
	currentDir, err := os.Getwd()
	if err != nil {
		logger.Fatalf("error getting current directory: %s", err)
	}
	logger.Infof("Current directory: %s", currentDir)

	// This ensures we are in the root directory of the project
	versionFile := "VERSION"
	if _, err := os.Stat(versionFile); os.IsNotExist(err) {
		logger.Fatalf("error: %s file does not exist", versionFile)
	}

	version, err := os.ReadFile(versionFile)
	if err != nil {
		logger.Fatalf("error reading %s file: %s", versionFile, err)
	}
	logger.Infof("VERSION: %s", string(version))

	// Load the configuration file, it will be generated by the config helper
	configData, err := os.ReadFile(orchConfigFile)
	if err != nil {
		logger.Fatalf("error reading config file %s: %s", orchConfigFile, err)
	}
	logger.Infof("Config file %s read successfully", orchConfigFile)
	orchInstallerConfig := internal.OrchInstallerConfig{}
	err = internal.DeserializeFromYAML(&orchInstallerConfig, configData)
	if err != nil {
		logger.Fatalf("error unmarshalling config file: %s", err)
	}

	// Load runtime state file
	if _, err := os.Stat(runtimeStateFile); os.IsNotExist(err) {
		err = os.WriteFile(runtimeStateFile, []byte{}, 0644)
		if err != nil {
			logger.Fatalf("error creating runtime state file %s: %s", runtimeStateFile, err)
		}
		logger.Infof("Runtime state file %s created successfully", runtimeStateFile)
	}
	runtimeState := &internal.OrchInstallerRuntimeState{}
	runtimeStateData, err := os.ReadFile(runtimeStateFile)
	if err != nil {
		logger.Fatalf("error reading runtime state file %s: %s", runtimeStateFile, err)
	}
	logger.Infof("Runtime state file %s read successfully", runtimeStateFile)
	err = internal.DeserializeFromYAML(runtimeState, runtimeStateData)
	if err != nil {
		logger.Fatalf("error unmarshalling runtime state file: %s", err)
	}
	runtimeState.Action = action
	runtimeState.LogDir = logDir

	logger.Infof("Action: %s", action)
	logger.Infof("Target environment: %s", orchInstallerConfig.TargetEnvironment)
	logger.Infof("Deployment name: %s", orchInstallerConfig.DeploymentName)

	// TODO: we will use switch-case to determine the stage to run
	// for now we will just run the demo stage
	stages := demo.CreateDemoStages(currentDir)
	orchInstaller, err := internal.CreateOrchInstaller(stages)
	if err != nil {
		logger.Fatalf("error creating orch installer: %s", err)
	}

	ctx, cancelFunc := context.WithTimeout(context.Background(), DefaultTimeout)
	signal.Ignore(syscall.SIGINT, syscall.SIGTERM)
	defer signal.Reset(syscall.SIGINT, syscall.SIGTERM)
	go func() {
		sig := make(chan os.Signal, 1)
		signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
		<-sig
		logger.Info("Received interrupt signal, cancelling the installation, ctrl+C one more time to force it...")
		logger.Sync()
		orchInstaller.CancelInstallation()
		cancelFunc()
		<-sig
		logger.Info("Installation cancelled")
		os.Exit(1)
	}()

	// TODO: Convert error to user friendly message and actions
	runErr := orchInstaller.Run(ctx, orchInstallerConfig, runtimeState)
	if runErr != nil {
		logger.Errorf("error running orch installer: %v", runErr)
	} else if orchInstaller.Cancelled() {
		logger.Info("Installation cancelled")
	} else {
		logger.Infof("Orch installer %s successfully", action)
	}

	runtimeStateData, err = internal.SerializeToYAML(runtimeState)
	if err != nil {
		logger.Errorf("error serializing runtime state: %s", err)
	} else {
		err = os.WriteFile(runtimeStateFile, runtimeStateData, 0644)
		if err != nil {
			logger.Errorf("error writing runtime state to file: %s", err)
		}
	}
}
