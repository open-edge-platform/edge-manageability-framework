# SPDX-FileCopyrightText: 2025 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

{{- if and .Values.keycloak.enabled .Values.configCli.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.keycloak.instanceName }}-config-bootstrap
  namespace: {{ .Values.keycloak.instanceNamespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "170"
  labels:
    app.kubernetes.io/name: keycloak-config-bootstrap
    app.kubernetes.io/instance: {{ .Values.keycloak.instanceName }}
    app.kubernetes.io/managed-by: platform-keycloak-helm
spec:
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: "false"
      labels:
        app.kubernetes.io/name: keycloak-config-bootstrap
        app.kubernetes.io/instance: {{ .Values.keycloak.instanceName }}
        app.kubernetes.io/managed-by: platform-keycloak-helm
        # Add Keycloak labels for network policy access
        app: keycloak
        app.kubernetes.io/component: config-bootstrap
    spec:
      restartPolicy: Never
      containers:
      - name: keycloak-config-bootstrap
        image: curlimages/curl:8.4.0
        imagePullPolicy: IfNotPresent
        command: ["/bin/sh"]
        args:
          - -c
          - |
            set -e
            echo "Starting Keycloak configuration bootstrap..."
            
            # Append Keycloak services to no_proxy to avoid proxy issues
            if [ -n "$no_proxy" ]; then
              export no_proxy="${no_proxy},platform-keycloak,platform-keycloak-service"
            else
              export no_proxy="platform-keycloak,platform-keycloak-service"
            fi
            if [ -n "$NO_PROXY" ]; then
              export NO_PROXY="${NO_PROXY},platform-keycloak,platform-keycloak-service"
            else
              export NO_PROXY="platform-keycloak,platform-keycloak-service"
            fi
            
            echo "no_proxy set to: $no_proxy"
            
            # Wait for Keycloak
            echo "Waiting for Keycloak to be available..."
            for i in $(seq 1 60); do
              if curl -f -s "$KEYCLOAK_URL/realms/master" > /dev/null; then
                echo "✓ Keycloak is available!"
                break
              fi
              echo "Waiting... ($i/60)"
              sleep 10
            done
            
            # Get admin token
            echo "Getting admin token..."
            TOKEN=$(curl -s -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
              -d "username=$KEYCLOAK_USER" \
              -d "password=$KEYCLOAK_PASSWORD" \
              -d "grant_type=password" \
              -d "client_id=admin-cli" | sed -n 's/.*"access_token":"\([^"]*\)".*/\1/p')
            
            if [ -z "$TOKEN" ]; then
              echo "ERROR: Failed to get admin token"
              exit 1
            fi
            echo "✓ Got admin token"
            
            # Delete existing system-client if it exists to ensure clean import
            echo "Checking for existing system-client..."
            CLIENT_ID=$(curl -s -X GET \
              "$KEYCLOAK_URL/admin/realms/master/clients?clientId=system-client" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" | sed -n 's/.*"id":"\([^"]*\)".*/\1/p' | head -n1)
            
            if [ -n "$CLIENT_ID" ]; then
              echo "Found existing system-client with ID: $CLIENT_ID, deleting..."
              curl -s -X DELETE \
                "$KEYCLOAK_URL/admin/realms/master/clients/$CLIENT_ID" \
                -H "Authorization: Bearer $TOKEN"
              echo "✓ Deleted existing system-client"
            else
              echo "No existing system-client found"
            fi
            
            # Create system-client directly via REST API
            echo "Creating system-client..."
            SYSTEM_CLIENT_JSON='{
              "clientId": "system-client",
              "name": "System Client",
              "enabled": true,
              "publicClient": true,
              "directAccessGrantsEnabled": true,
              "standardFlowEnabled": false,
              "implicitFlowEnabled": false,
              "serviceAccountsEnabled": false,
              "protocol": "openid-connect",
              "attributes": {
                "oidc.ciba.grant.enabled": "false",
                "oauth2.device.authorization.grant.enabled": "true",
                "backchannel.logout.session.required": "true",
                "backchannel.logout.revoke.offline.tokens": "false"
              }
            }'
            
            response=$(curl -s -w "\n%{http_code}" -X POST \
              "$KEYCLOAK_URL/admin/realms/master/clients" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d "$SYSTEM_CLIENT_JSON")
            
            http_code=$(echo "$response" | tail -n1)
            body=$(echo "$response" | sed '$d')
            
            echo "HTTP Code: $http_code"
            if [ -n "$body" ]; then
              echo "Response Body: $body"
            fi
            
            if [ "$http_code" = "201" ]; then
              echo "✓ system-client created successfully"
            else
              echo "WARNING: Client creation returned HTTP $http_code"
              exit 1
            fi
            
            # Create openid and groups client scopes if they don't exist
            echo "Ensuring openid and groups client scopes exist..."
            
            # Create openid scope
            OPENID_SCOPE='{
              "name": "openid",
              "protocol": "openid-connect",
              "attributes": {
                "include.in.token.scope": "true",
                "display.on.consent.screen": "true"
              }
            }'
            curl -s -X POST "$KEYCLOAK_URL/admin/realms/master/client-scopes" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d "$OPENID_SCOPE" 2>/dev/null || echo "  openid scope may already exist"
            
            # Create groups scope
            GROUPS_SCOPE='{
              "name": "groups",
              "protocol": "openid-connect",
              "attributes": {
                "include.in.token.scope": "true",
                "display.on.consent.screen": "true"
              },
              "protocolMappers": [{
                "name": "groups",
                "protocol": "openid-connect",
                "protocolMapper": "oidc-group-membership-mapper",
                "config": {
                  "claim.name": "groups",
                  "full.path": "false",
                  "id.token.claim": "true",
                  "access.token.claim": "true",
                  "userinfo.token.claim": "true"
                }
              }]
            }'
            curl -s -X POST "$KEYCLOAK_URL/admin/realms/master/client-scopes" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              -d "$GROUPS_SCOPE" 2>/dev/null || echo "  groups scope may already exist"
            
            echo "✓ Client scopes ensured"
            
            # Get the system-client UUID
            echo "Getting system-client UUID..."
            SYSTEM_CLIENT_UUID=$(curl -s -X GET \
              "$KEYCLOAK_URL/admin/realms/master/clients?clientId=system-client" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" | sed -n 's/.*"id":"\([^"]*\)".*/\1/p' | head -n1)
            
            if [ -z "$SYSTEM_CLIENT_UUID" ]; then
              echo "ERROR: Could not find system-client UUID"
              exit 1
            fi
            echo "system-client UUID: $SYSTEM_CLIENT_UUID"
            
            # Assign default client scopes to system-client
            echo "Assigning client scopes to system-client..."
            for scope_name in openid roles profile email basic groups; do
              echo "  Assigning scope: $scope_name"
              
              # Query for the specific scope by name
              SCOPE_RESPONSE=$(curl -s -X GET \
                "$KEYCLOAK_URL/admin/realms/master/client-scopes" \
                -H "Authorization: Bearer $TOKEN")
              
              # Extract UUID for this specific scope
              # Use awk to find the scope object and extract its id
              SCOPE_UUID=$(echo "$SCOPE_RESPONSE" | awk -v name="$scope_name" '
                BEGIN { RS="},"; FS="\""; found=0 }
                {
                  if ($0 ~ "\"name\":\"" name "\"") {
                    for (i=1; i<=NF; i++) {
                      if ($i == "id" && $(i+2) != "") {
                        print $(i+2);
                        found=1;
                        exit;
                      }
                    }
                  }
                }
              ')
              
              if [ -z "$SCOPE_UUID" ]; then
                echo "    WARNING: Client scope '$scope_name' not found, skipping"
                continue
              fi
              
              echo "    Found scope UUID: $SCOPE_UUID"
              
              # Assign the scope to the client
              ASSIGN_RESULT=$(curl -s -w "\n%{http_code}" -X PUT \
                "$KEYCLOAK_URL/admin/realms/master/clients/$SYSTEM_CLIENT_UUID/default-client-scopes/$SCOPE_UUID" \
                -H "Authorization: Bearer $TOKEN")
              
              HTTP_CODE=$(echo "$ASSIGN_RESULT" | tail -n1)
              if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
                echo "    ✓ Assigned $scope_name"
              else
                echo "    WARNING: Assignment returned HTTP $HTTP_CODE"
              fi
            done
            
            echo "✓ All scopes assigned to system-client"
            
            echo "✓ Keycloak configuration bootstrap completed!"
        env:
        - name: KEYCLOAK_URL
          value: "http://{{ .Values.keycloak.instanceName }}-service:8080"
        - name: KEYCLOAK_USER
          valueFrom:
            secretKeyRef:
              name: {{ .Values.configCli.auth.secretName }}
              key: {{ .Values.configCli.auth.usernameKey }}
        - name: KEYCLOAK_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ .Values.configCli.auth.secretName }}
              key: {{ .Values.configCli.auth.passwordKey }}
        {{- if .Values.keycloak.additionalOptions }}
        {{- range .Values.keycloak.additionalOptions }}
        {{- if or (eq .name "HTTP_PROXY") (eq .name "HTTPS_PROXY") (eq .name "NO_PROXY") }}
        - name: {{ .name }}
          value: {{ .value | quote }}
        {{- if eq .name "HTTP_PROXY" }}
        - name: http_proxy
          value: {{ .value | quote }}
        {{- end }}
        {{- if eq .name "HTTPS_PROXY" }}
        - name: https_proxy
          value: {{ .value | quote }}
        {{- end }}
        {{- if eq .name "NO_PROXY" }}
        - name: no_proxy
          value: {{ .value | quote }}
        {{- end }}
        {{- end }}
        {{- end }}
        {{- end }}
        volumeMounts:
        - name: config
          mountPath: /config
          readOnly: true
        - name: tmp
          mountPath: /tmp
        resources:
          {{- toYaml .Values.configCli.resources | nindent 10 }}
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 65532
          seccompProfile:
            type: RuntimeDefault
      volumes:
      - name: config
        configMap:
          name: {{ .Values.keycloak.instanceName }}-config
      - name: tmp
        emptyDir: {}
      securityContext:
        fsGroup: 65532
        fsGroupChangePolicy: Always
{{- end }}
