// SPDX-FileCopyrightText: 2025 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/open-edge-platform/edge-manageability-framework/installer/internal"
	"github.com/open-edge-platform/edge-manageability-framework/installer/targets/aws"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
)

// TODO: make a flag for this
const DefaultTimeout = 60 * time.Minute

func main() {
	// Initialize the command line interface
	rootCmd := &cobra.Command{
		Use:   "orch-installer",
		Short: "Orchestrator Installer",
		Long:  `Orchestrator Installer for the Open Edge Platform`,
		Run:   func(cmd *cobra.Command, args []string) {},
	}

	// These flages are common to all commands
	var configFile, logLevel, logDir string
	var keepGeneratedFiles bool
	rootCmd.PersistentFlags().StringVarP(&configFile, "config", "c", "config.yaml", "Path to the configuration file")
	rootCmd.PersistentFlags().StringVarP(&logLevel, "log-level", "l", "info", "Log level (debug, info, warn, error)")
	rootCmd.PersistentFlags().StringVarP(&logDir, "log-dir", "o", ".logs", "Path to the log dir")
	rootCmd.PersistentFlags().BoolVarP(&keepGeneratedFiles, "keep-generated-files", "k", false, "Keep generated files")

	commands := []struct {
		use   string
		short string
		long  string
	}{
		{"install", "Install the orchestrator", "Install the orchestrator"},
		{"uninstall", "Uninstall the orchestrator", "Uninstall the orchestrator"},
		{"upgrade", "Upgrade the orchestrator", "Upgrade the orchestrator"},
	}

	for _, cmd := range commands {
		c := &cobra.Command{
			Use:   cmd.use,
			Short: cmd.short,
			Long:  cmd.long,
			Run: func(cmd *cobra.Command, args []string) {
				err := internal.InitLogger(logLevel, logDir)
				if err != nil {
					zap.S().Fatalf("error initializing logger: %s", err)
				}
				execute(cmd.Name(), configFile, logDir, keepGeneratedFiles)
			},
		}
		rootCmd.AddCommand(c)
	}
	rootCmd.Execute()
}

func execute(action string, orchConfigFile string, logDir string, keepGeneratedFiles bool) {
	logger := zap.S()
	currentDir, err := os.Getwd()
	if err != nil {
		logger.Fatalf("error getting current directory: %s", err)
	}
	logger.Infof("Current directory: %s", currentDir)

	// This ensures we are in the root directory of the project
	versionFile := "VERSION"
	if _, err := os.Stat(versionFile); os.IsNotExist(err) {
		logger.Fatalf("error: %s file does not exist", versionFile)
	}

	version, err := os.ReadFile(versionFile)
	if err != nil {
		logger.Fatalf("error reading %s file: %s", versionFile, err)
	}
	logger.Infof("VERSION: %s", string(version))

	// Load the configuration file, it will be generated by the config helper
	configData, err := os.ReadFile(orchConfigFile)
	if err != nil {
		logger.Fatalf("error reading config file %s: %s", orchConfigFile, err)
	}
	logger.Infof("Config file %s read successfully", orchConfigFile)
	config := internal.OrchInstallerConfig{}
	err = internal.DeserializeFromYAML(&config, configData)
	if err != nil {
		logger.Fatalf("error unmarshalling config file: %s", err)
	}

	config.Generated.Action = action
	config.Generated.LogDir = logDir

	logger.Infof("Action: %s", action)
	logger.Infof("Target environment: %s", config.Provider)
	logger.Infof("Orchestrator name: %s", config.Global.OrchName)

	var stages []internal.OrchInstallerStage
	switch config.Provider {
	case "aws":
		stages = aws.CreateAWSStages(currentDir, keepGeneratedFiles)
	default:
		logger.Fatalf("error: target environment %s not supported", config.Provider)
	}
	orchInstaller, err := internal.CreateOrchInstaller(stages)
	if err != nil {
		logger.Fatalf("error creating orch installer: %s", err)
	}

	ctx, cancelFunc := context.WithTimeout(context.Background(), DefaultTimeout)
	signal.Ignore(syscall.SIGINT, syscall.SIGTERM)
	defer signal.Reset(syscall.SIGINT, syscall.SIGTERM)
	go func() {
		sig := make(chan os.Signal, 1)
		signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
		<-sig
		logger.Info("Received interrupt signal, cancelling the installation, ctrl+C one more time to force it...")
		logger.Sync()
		orchInstaller.CancelInstallation()
		cancelFunc()
		<-sig
		logger.Info("Installation cancelled")
		os.Exit(1)
	}()

	// TODO: Convert error to user friendly message and actions
	runErr := orchInstaller.Run(ctx, config)
	if runErr != nil {
		logger.Infof("error running orch installer: %v", runErr)
	} else if orchInstaller.Cancelled() {
		logger.Info("Installation cancelled")
	} else {
		logger.Infof("Orch installer %s successfully", action)
	}

	err = aws.UploadStateToS3(config)
	if err != nil {
		logger.Errorf("error uploading state to S3: %s", err)
	}
}
