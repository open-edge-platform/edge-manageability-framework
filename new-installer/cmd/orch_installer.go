// SPDX-FileCopyrightText: 2025 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/open-edge-platform/edge-manageability-framework/installer/internal"
	"github.com/open-edge-platform/edge-manageability-framework/installer/internal/config"
	"github.com/open-edge-platform/edge-manageability-framework/installer/targets/aws"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
)

// TODO: make a flag for this
const DefaultTimeout = 60 * time.Minute

func main() {
	// Initialize the command line interface
	rootCmd := &cobra.Command{
		Use:   "orch-installer",
		Short: "Orchestrator Installer",
		Long:  `Orchestrator Installer for the Open Edge Platform`,
		Run:   func(cmd *cobra.Command, args []string) {},
	}

	// These flags are common to all commands
	var configFile, runtimeStateFile, logLevel, logDir string
	var keepGeneratedFiles bool
	rootCmd.PersistentFlags().StringVarP(&configFile, "config", "c", "config.yaml", "Path to the configuration file")
	rootCmd.PersistentFlags().StringVarP(&runtimeStateFile, "runtime-state", "r", "config.yaml", "Path to the runtime state file")
	rootCmd.PersistentFlags().StringVarP(&logLevel, "log-level", "l", "info", "Log level (debug, info, warn, error)")
	rootCmd.PersistentFlags().StringVarP(&logDir, "log-dir", "o", ".logs", "Path to the log dir")
	rootCmd.PersistentFlags().BoolVarP(&keepGeneratedFiles, "keep-generated-files", "k", false, "Keep generated files, such as Terraform backend config and variables files.")

	commands := []struct {
		use   string
		short string
		long  string
	}{
		{"install", "Install the orchestrator", "Install the orchestrator"},
		{"uninstall", "Uninstall the orchestrator", "Uninstall the orchestrator"},
		{"upgrade", "Upgrade the orchestrator", "Upgrade the orchestrator"},
	}

	for _, cmd := range commands {
		c := &cobra.Command{
			Use:   cmd.use,
			Short: cmd.short,
			Long:  cmd.long,
			Run: func(cmd *cobra.Command, args []string) {
				err := internal.InitLogger(logLevel, logDir)
				if err != nil {
					zap.S().Fatalf("error initializing logger: %s", err)
				}
				execute(cmd.Name(), configFile, runtimeStateFile, logDir, keepGeneratedFiles)
			},
		}
		rootCmd.AddCommand(c)
	}
	rootCmd.Execute()
}

func execute(action string, orchConfigFile string, runtimeStateFile string, logDir string, keepGeneratedFiles bool) {
	logger := zap.S()
	currentDir, err := os.Getwd()
	if err != nil {
		logger.Fatalf("error getting current directory: %s", err)
	}
	logger.Infof("Current directory: %s", currentDir)

	// This ensures we are in the root directory of the project
	versionFile := "VERSION"
	if _, err := os.Stat(versionFile); os.IsNotExist(err) {
		logger.Fatalf("error: %s file does not exist", versionFile)
	}

	installerVersion, err := os.ReadFile(versionFile)
	if err != nil {
		logger.Fatalf("error reading %s file: %s", versionFile, err)
	}
	logger.Infof("Installer version: %s", string(installerVersion))

	// Load the configuration file, it will be generated by the config helper
	orchConfigReaderWriter := config.FileBaseOrchConfigReaderWriter{
		OrchConfigFilePath:   orchConfigFile,
		RuntimeStateFilePath: runtimeStateFile,
	}
	orchConfig, err := orchConfigReaderWriter.ReadOrchConfig()
	if err != nil {
		logger.Fatalf("error reading config file %s: %s", orchConfigFile, err)
	}
	runtimeState, err := orchConfigReaderWriter.ReadRuntimeState()
	if err != nil {
		logger.Fatalf("error reading runtime state file: %s", err)
	}

	if orchConfig.Version != config.UserConfigVersion {
		logger.Fatalf("error: orchestrator config version %s does not match installer version %s", orchConfig.Version, config.UserConfigVersion)
	}
	// We will check and migrate runtime state version later in the installer.

	runtimeState.Action = action
	runtimeState.LogDir = logDir

	logger.Infof("Action: %s", action)
	logger.Infof("Target environment: %s", orchConfig.Provider)
	logger.Infof("Orchestrator name: %s", orchConfig.Global.OrchName)
	logger.Infof("Orchestrator config version: %s", orchConfig.Version)

	if orchConfig.Version != config.UserConfigVersion {
		logger.Fatalf("error: orchestrator config version %s does not match installer version %d", orchConfig.Version, config.UserConfigVersion)
	}

	var stages []internal.OrchInstallerStage
	switch orchConfig.Provider {
	case "aws":
		stages, err = aws.CreateAWSStages(currentDir, keepGeneratedFiles, &orchConfigReaderWriter)
	default:
		logger.Fatalf("error: target environment %s not supported", orchConfig.Provider)
	}
	if err != nil {
		logger.Fatalf("error creating stages for provider %s: %s", orchConfig.Provider, err)
	}
	orchInstaller, err := internal.CreateOrchInstaller(stages)
	if err != nil {
		logger.Fatalf("error creating orch installer: %s", err)
	}

	ctx, cancelFunc := context.WithTimeout(context.Background(), DefaultTimeout)
	signal.Ignore(syscall.SIGINT, syscall.SIGTERM)
	defer signal.Reset(syscall.SIGINT, syscall.SIGTERM)
	go func() {
		sig := make(chan os.Signal, 1)
		signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
		<-sig
		logger.Info("Received interrupt signal, cancelling the installation, ctrl+C one more time to force it...")
		logger.Sync()
		orchInstaller.CancelInstallation()
		cancelFunc()
		<-sig
		logger.Info("Installation cancelled")
		os.Exit(1)
	}()

	runErr := orchInstaller.Run(ctx, orchConfig, &runtimeState)
	rsWriteErr := orchConfigReaderWriter.WriteRuntimeState(runtimeState) // TODO: handle error here
	if rsWriteErr != nil {
		logger.Errorf("error writing runtime state file: %s", rsWriteErr)
	}
	if runErr != nil {
		logger.Infof("error running orch installer: %v", runErr)
		showActionsForError(runErr)
	} else if orchInstaller.Cancelled() {
		logger.Info("Installation cancelled")
	} else {
		logger.Infof("Orch installer %s successfully", action)
	}
}

func showActionsForError(err *internal.OrchInstallerError) {
	logger := zap.S()
	switch err.ErrorCode {
	case internal.OrchInstallerErrorCodeUnknown:
		logger.Error("An unknown error occurred, please check the logs for more details.")
	case internal.OrchInstallerErrorCodeInternal:
		logger.Error("An internal error occurred, please check the logs for more details.")
	case internal.OrchInstallerErrorCodeInvalidArgument:
		logger.Error("Invalid argument provided, please check the configuration file and command line arguments.")
	case internal.OrchInstallerErrorCodeTerraform:
		logger.Error("An error occurred while running Terraform, please check the Terraform logs for more details.")
	default:
		logger.Error("An unexpected error occurred, please check the logs for more details.")
	}
}
