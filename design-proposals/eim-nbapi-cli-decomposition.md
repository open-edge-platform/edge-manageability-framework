# Design Proposal: Exposing only the required North Bound APIs and CLI commands for the workflow as part of EIM decomposition

Author(s) EIM-Core team

Last updated: 7/11/25

## Abstract

In context of EIM decomposition the North Bound API service should be treated as an independent interchangeable module.
The [EIM proposal for modular decomposition](https://github.com/open-edge-platform/edge-manageability-framework/blob/main/design-proposals/eim-modular-decomposition.md) calls out a need for exposing both a full set of EMF APIs, and a need for exposing only a subset of APIs as required by individual workflows taking advantage of a modular architecture. This proposal will explore, how the APIs can be decomposed and how the decomposed output can be used as version of API service module.

## Background and Context

In EMF 2025.2 the API service is deployed via a helm chart deployed by Argo CD. The API service is run and deployed in a container kick-started from the API service container image. The API is build using the OpenAPI spec. There are multiple levels of APIs currently available with individual specs available for each domain in [orch-utils](https://github.com/open-edge-platform/orch-utils/tree/main/tenancy-api-mapping/openapispecs/generated)

The list of domain APIs include:

- Catalog and Catalog utilities APIs
- App deployment manager and app resource manager APIs
- Cluster APIs
- EIM APIs
- Alert Monitoring APIs
- MPS and RPS APIs
- Metadata broker and Tenancy APIs

There are two levels to the API decomposition

- Decomposition of above domain levels
- Decomposition within domain (ie. separation at EIM domain level, where overall set of APIs includes onboarding/provisioning/day2 APIs but another workflow may support only onboarding/provisioning without day2 support )

The following questions must be answered and investigated:

- How the API service is build currently
  - It is build from a proto definition and code is autogenerated by "buf" tool - [See How NB API is Currently Built](#how-nb-api-is-currently-built)
- How the API service container image is build currently
- How the API service helm charts are build currently
- What level of decomposition is needed from the required workflows
- How to decomposition API at domain level
  - At domain level the APIs are deployed as separate services
- How to decomposition API within domain level
- How to build various API service version as per desired workflows using the modular APIs
- How to deliver the various API service versions as per desired workflows
- How to expose the list of available APIs for client consumption (orch-cli)

Uncertainties:

- How does potential removal of the API gateway affect the exposing of the APIs to the client
- How will the decomposition and availability of APIs within the API service be mapped back to the Inventory and the set of SB APIs.

### Decomposing the release of API service as a module

Once the investigation is completed on how the API service is created today decisions must be done on how the service will be build and released as a module.

- The build of the API service itself will depend on the results of "top to bottom" and "bottom to top" decomposition investigations.
- The individual versions of API service can be packaged as versioned container images:
  - apiv2-emf:x.x.x
  - apiv2-workflow1:x.x.x
  - apiv2-workflow2:x.x.x
- Alternatively if the decomposition does not result in multiple version of the API service the service could be released as same docker image but managed by flags provided to container that alter the behaviour of the API service in runtime.
- The API service itself should still be packaged for deployment as a helmchart regardless of deployment via ArgoCD or other medium/technique. Decision should be made if common helmchart is used with override values for container image and other related values (preferred) or individual helmcharts need to be released.

### Decomposing the API service

An investigation needs to be conducted into how the API service can be decomposed to be rebuilt as various flavours of same API service providing different set of APIs.

- Preferably the total set of APIs serves as the main source of the API service, and other flavours/subsets are automatically derived from this based on the required functionality. Making the maintenance of the API simple and in one place.
- The APIs service should be decomposed at the domain level meaning that all domains or subset of domains should be available as part of the EMF - they are already decomposed/modular at this level and deployed as separate services.
- The APIs service should be decomposed within the domain level meaning that only subset of the available APIs may need to be released and/or exposed at API service level. As an example within the EIM domain we may not want to expose the Day 2 functionality for some workflows which currently are part of the EIM OpenAPI spec.
- The APIs service may also need to be decomposed at individual internal service level ie host resource may need to ha different data model across use cases.

The following are the usual options to decomposing or exposing subsets of APIs.

- ~~API Gateway that would only expose certain endpoints to user~~ - this is a no go for us as we plan to remove the existing API Gateway and it does not actually solve the problem of releasing only specific flavours of EMF.
- Maintain multiple OpenAPI specification - while possible to create multiple OpenAPI specs, the maintenance of same APIs across specs will be a large burden - still let's keep this option in consideration in terms of auto generating multiple specs from top spec.
- ~~Authentication & Authorization Based Filtering~~ - this is a no go for us as we do not control the end users of the EMF, and we want to provide tailored modular product for each workflow.
- ~~API Versioning strategy~~ - Creating different API versions for each use-case - too much overhead without benefits similar to maintaining multiple OpenAPI specs.
- ~~Proxy/Middleware Layer~~ - Similar to API Gateway - does not fit our use cases
- OpenAPI Spec Manipulation - This approach uses OpenAPI's extension mechanism (properties starting with x-) to add metadata that describes which audiences, use cases, or clients should have access to specific endpoints, operations, or schemas. This approach is worth investigating to see if it can give us the automated approach for creating individual OpenAPI specs for workflows based on labels.
- Other approach to manipulate how a flavour of OpenAPIs spec can be generated from main spec, or how the API service can be build conditionally using same spec.

### Consuming the APIs from the CLI

The best approach would be for the EMF to provide a service/endpoint that will communicate which endpoints/APIs are currently supported by the deployed API service. The CLI would then request that information on login, save the configuration and prevent from using non-supported APIs/commands. The prevention could happen at command call level where a configuration would be checked before a RUNe command is called for a given command.


## Summary

1. Assuming that in phase 1 we will retain Traefik for all workflows, we need to check how the Traefik->EIM mapping will behave and needs to behave when EIM only supports subset of APIs, and establish if the set of API calls supported by Treafik API Gateway maps to the supported APIs in EIM API service subset.
2. We need to make sure that our API supports specific usecases and on the other hand it needs to keep compatibility with other workflows - to achieve that, we may need to make code changes in data models. As an example we need to make sure that mandatory fields are supported accordingly across usecases ie. instance creation will require OSprofile for general usecase, but this may not be true for self installed OSes/Edge Nodes. Collaboration with teams/ADR owners is needed to establish what changes are needed at Resource Manager/Inventory levels to accommodate workflows and how will the changes impact the APIs.
3. We need to understand all the scenarios and required services to be supported. And define the APIs per scenario.

## How NB API is Currently Built

Currently apiv2 (infra-core repository) stores REST API definitions of services in protocol buffer files (.proto) and uses protoc-gen-connect-openapi to autogenerate the openapi spec - openapi.yaml .  

Content of api/proto Directory - two folders:
services - API Operations (Service Layer) - this is one file services.yaml that  contains API operation on all the available resources.
resources - Data Models (DTOs/Entities) - separate file per each resource.

Protoc-gen-connect-openapi is the tool that is indirectly used to build the openapi spec - it is configured as a plugin in buf (buf.gen.yaml). User calls "buf generate" within the "make generate" or "make buf-gen" target. This plugin generates OpenAPI 3.0 specifications directly from .proto files in api/proto/ directory.

The following is the current, full buf configuration:# (buf.gen.yaml)

```yaml
plugins:
  # go - https://pkg.go.dev/google.golang.org/protobuf
  - name: go
    out: internal/pbapi
    opt:
      - paths=source_relative

  # go grpc - https://pkg.go.dev/google.golang.org/grpc
  - name: go-grpc
    out: internal/pbapi
    opt:
      - paths=source_relative
      - require_unimplemented_servers=false

  # go install github.com/sudorandom/protoc-gen-connect-openapi@v0.17.0
  - name: connect-openapi
    path: protoc-gen-connect-openapi
    out: api/openapi
    strategy: all
    opt:
      - format=yaml
      - short-service-tags
      - short-operation-ids
      - path=openapi.yaml

  # grpc-gateway - https://grpc-ecosystem.github.io/grpc-gateway/
  - name: grpc-gateway
    out: internal/pbapi
    opt:
      - paths=source_relative

  # docs - https://github.com/pseudomuto/protoc-gen-doc
  - plugin: doc
    out: docs
    opt: markdown,proto.md
    strategy: all

  - plugin: go-const
    out: internal/pbapi
    path: ["go", "run", "./cmd/protoc-gen-go-const"]
    opt:
      - paths=source_relative
```

The plugin takes as an input one full openapi spec that includes all services (services.proto).

Key Items:
- Input: api/proto/**/*.proto
- Config: buf.gen.yaml, buf.work.yaml, buf.yaml
- Output: openapi.yaml
- Tool: protoc-gen-connect-openapi

Buf also generates:
- the Go code ( Go structs, gRPC clients/services) in internal/pbapi
- gRPC gateway: REST to gRPC proxy code - HTTP handlers that proxy REST calls to gRPC (in internal/pbapi/**/*.pb.gw.go )
- documentation: docs/proto.md

Next, targets "oapi-patch" and "oapi-banner" are executed on the generated openapi.yaml file:

"make oapi-patch" - post-process: cleans up the generated OpenAPI by removing verbose proto package prefixes (e.g.: resources.compute.v1.HostResource â†’ HostResource)

## Solution 1

Split services.yaml file into multiple files per service, then change make buf-gen target to process only services used by the scenario, example:

```bash
bug generate --path api/proto/services/instance/v1 api/proto/services/os/v1
```

This generates the openapi spec openapi.yaml only for the services supported by particular scenario.

## Soultion 2 - more robust

- Generate full openapi.yaml file with "buf generate" same way it is done now. buf already generates the spec with option 'short-service-tags'.  This means it adds a tag to each service in the openapi spec matching its service name.
- Write a small filter that will parse the spec and select only operations per service with a certain service-tag and generate a new spec supporting only the particular scenario.

We can add some manifest that will store the list of services per scenario.

## Solution 3

No splitting of service.yaml .
This approach uses custom annotations/options to connect services to scenarios.

- define custom option/annotations by extending google.protobuf.ServiceOptions and google.protobuf.MethodOptions, example:

```go
syntax = "proto3";
package annotations.common.v1;

import "google/protobuf/descriptor.proto";

// Service-level: applies to the whole service (default)
extend google.protobuf.ServiceOptions {
  repeated string scenario = 50001; // e.g., ["scenario-1", "scenario-2"]
}

// Method-level: override/add per RPC if needed
extend google.protobuf.MethodOptions {
  repeated string scenario = 50011;
}
```
Add the file to api/proto/annotations.

Use it in api/proto/services/services.proto:

Service level selection per scenario:
```go
(...)
import "annotations/scenario_annotations.proto";
(...)
service OSUpdateRun {
  option (annotations.common.v1.scenario) = "scenario-1";
  // Get a list of OS Update Runs.
  rpc ListOSUpdateRun(ListOSUpdateRunRequest) returns (ListOSUpdateRunResponse) {
    option (google.api.http) = {get: "/edge-infra.orchestrator.apis/v2/os_update_run"};
  }
  // Get a specific OS Update Run.
  rpc GetOSUpdateRun(GetOSUpdateRunRequest) returns (resources.compute.v1.OSUpdateRun) {
    option (google.api.http) = {get: "/edge-infra.orchestrator.apis/v2/os_update_run/{resourceId}"};
  }
  // Delete a OS Update Run.
  rpc DeleteOSUpdateRun(DeleteOSUpdateRunRequest) returns (DeleteOSUpdateRunResponse) {
    option (google.api.http) = {delete: "/edge-infra.orchestrator.apis/v2/os_update_run/{resourceId}"};
  }
}
(...)
```

Or:

Method level selection per scenario:
```go
(...)
import "annotations/scenario_annotations.proto";
(...)
service OSUpdateRun {
  // Get a list of OS Update Runs.
  rpc ListOSUpdateRun(ListOSUpdateRunRequest) returns (ListOSUpdateRunResponse) {
    option (annotations.common.v1.scenario) = "scenario-1";
    option (google.api.http) = {get: "/edge-infra.orchestrator.apis/v2/os_update_run"};
  }
  // Get a specific OS Update Run.
  rpc GetOSUpdateRun(GetOSUpdateRunRequest) returns (resources.compute.v1.OSUpdateRun) {
    option (google.api.http) = {get: "/edge-infra.orchestrator.apis/v2/os_update_run/{resourceId}"};
  }
  // Delete a OS Update Run.
  rpc DeleteOSUpdateRun(DeleteOSUpdateRunRequest) returns (DeleteOSUpdateRunResponse) {
    option (google.api.http) = {delete: "/edge-infra.orchestrator.apis/v2/os_update_run/{resourceId}"};
  }
}
(...)
```

- Use buf generate to generate the full openapi.yaml spec.

- Create and run a filter that reads generated .pb file that contains new service annotations, takes openapi.yaml as input and removes all services without the scenario annotation. The filter also takes as input the scenario name and returns a scenario specific openapi spec.
- OR patch the spec generating tool ( protoc-gen-connect-openapi) so it supports new annotations and includes them in the new full spec - so it reads your annotations directly and writes x-* fields into the OpenAPI. It will create an openapi spec with fields and services annotatted by a specific scenario.  This requires literally creating a custom plugin that takes scenario as input and generates openapi spec per scenario only - wrapper of protoc-gen-connect-openapi. 
